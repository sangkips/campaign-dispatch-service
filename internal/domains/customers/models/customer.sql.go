// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: customer.sql

package models

import (
	"context"
	"database/sql"
)

const countCustomers = `-- name: CountCustomers :one
SELECT COUNT(*) FROM customer
`

func (q *Queries) CountCustomers(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countCustomers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCustomer = `-- name: CreateCustomer :one
INSERT INTO customer (
    phone,
    firstname,
    lastname,
    location,
    prefered_product
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5
)
RETURNING id, phone, firstname, lastname, location, prefered_product, created_at
`

type CreateCustomerParams struct {
	Phone           string         `json:"phone"`
	Firstname       string         `json:"firstname"`
	Lastname        string         `json:"lastname"`
	Location        sql.NullString `json:"location"`
	PreferedProduct sql.NullString `json:"prefered_product"`
}

func (q *Queries) CreateCustomer(ctx context.Context, arg CreateCustomerParams) (Customer, error) {
	row := q.db.QueryRowContext(ctx, createCustomer,
		arg.Phone,
		arg.Firstname,
		arg.Lastname,
		arg.Location,
		arg.PreferedProduct,
	)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.Phone,
		&i.Firstname,
		&i.Lastname,
		&i.Location,
		&i.PreferedProduct,
		&i.CreatedAt,
	)
	return i, err
}

const deleteCustomer = `-- name: DeleteCustomer :exec
DELETE FROM customer
WHERE id = $1
`

func (q *Queries) DeleteCustomer(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteCustomer, id)
	return err
}

const getCustomer = `-- name: GetCustomer :one
SELECT id, phone, firstname, lastname, location, prefered_product, created_at FROM customer
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetCustomer(ctx context.Context, id int32) (Customer, error) {
	row := q.db.QueryRowContext(ctx, getCustomer, id)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.Phone,
		&i.Firstname,
		&i.Lastname,
		&i.Location,
		&i.PreferedProduct,
		&i.CreatedAt,
	)
	return i, err
}

const getCustomerByPhone = `-- name: GetCustomerByPhone :one
SELECT id, phone, firstname, lastname, location, prefered_product, created_at FROM customer
WHERE phone = $1 LIMIT 1
`

func (q *Queries) GetCustomerByPhone(ctx context.Context, phone string) (Customer, error) {
	row := q.db.QueryRowContext(ctx, getCustomerByPhone, phone)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.Phone,
		&i.Firstname,
		&i.Lastname,
		&i.Location,
		&i.PreferedProduct,
		&i.CreatedAt,
	)
	return i, err
}

const getCustomerForPreview = `-- name: GetCustomerForPreview :one
SELECT id, firstname, lastname, location, prefered_product, phone
FROM customer
WHERE id = $1 LIMIT 1
`

type GetCustomerForPreviewRow struct {
	ID              int32          `json:"id"`
	Firstname       string         `json:"firstname"`
	Lastname        string         `json:"lastname"`
	Location        sql.NullString `json:"location"`
	PreferedProduct sql.NullString `json:"prefered_product"`
	Phone           string         `json:"phone"`
}

func (q *Queries) GetCustomerForPreview(ctx context.Context, id int32) (GetCustomerForPreviewRow, error) {
	row := q.db.QueryRowContext(ctx, getCustomerForPreview, id)
	var i GetCustomerForPreviewRow
	err := row.Scan(
		&i.ID,
		&i.Firstname,
		&i.Lastname,
		&i.Location,
		&i.PreferedProduct,
		&i.Phone,
	)
	return i, err
}

const getCustomersByLocation = `-- name: GetCustomersByLocation :many
SELECT id, phone, firstname, lastname, location, prefered_product, created_at FROM customer
WHERE location ILIKE '%' || $1 || '%'
ORDER BY created_at DESC
LIMIT $3 OFFSET $2
`

type GetCustomersByLocationParams struct {
	Location sql.NullString `json:"location"`
	Offset   int32          `json:"offset"`
	Limit    int32          `json:"limit"`
}

func (q *Queries) GetCustomersByLocation(ctx context.Context, arg GetCustomersByLocationParams) ([]Customer, error) {
	rows, err := q.db.QueryContext(ctx, getCustomersByLocation, arg.Location, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Customer
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.ID,
			&i.Phone,
			&i.Firstname,
			&i.Lastname,
			&i.Location,
			&i.PreferedProduct,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCustomersByPreferredProduct = `-- name: GetCustomersByPreferredProduct :many
SELECT id, phone, firstname, lastname, location, prefered_product, created_at FROM customer
WHERE prefered_product = $1
ORDER BY created_at DESC
LIMIT $3 OFFSET $2
`

type GetCustomersByPreferredProductParams struct {
	PreferedProduct sql.NullString `json:"prefered_product"`
	Offset          int32          `json:"offset"`
	Limit           int32          `json:"limit"`
}

func (q *Queries) GetCustomersByPreferredProduct(ctx context.Context, arg GetCustomersByPreferredProductParams) ([]Customer, error) {
	rows, err := q.db.QueryContext(ctx, getCustomersByPreferredProduct, arg.PreferedProduct, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Customer
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.ID,
			&i.Phone,
			&i.Firstname,
			&i.Lastname,
			&i.Location,
			&i.PreferedProduct,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCustomers = `-- name: ListCustomers :many
SELECT id, phone, firstname, lastname, location, prefered_product, created_at FROM customer
ORDER BY created_at DESC
LIMIT $2 OFFSET $1
`

type ListCustomersParams struct {
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) ListCustomers(ctx context.Context, arg ListCustomersParams) ([]Customer, error) {
	rows, err := q.db.QueryContext(ctx, listCustomers, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Customer
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.ID,
			&i.Phone,
			&i.Firstname,
			&i.Lastname,
			&i.Location,
			&i.PreferedProduct,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchCustomersByName = `-- name: SearchCustomersByName :many
SELECT id, phone, firstname, lastname, location, prefered_product, created_at FROM customer
WHERE firstname ILIKE '%' || $1 || '%' 
   OR lastname ILIKE '%' || $1 || '%'
ORDER BY created_at DESC
LIMIT $3 OFFSET $2
`

type SearchCustomersByNameParams struct {
	Search sql.NullString `json:"search"`
	Offset int32          `json:"offset"`
	Limit  int32          `json:"limit"`
}

func (q *Queries) SearchCustomersByName(ctx context.Context, arg SearchCustomersByNameParams) ([]Customer, error) {
	rows, err := q.db.QueryContext(ctx, searchCustomersByName, arg.Search, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Customer
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.ID,
			&i.Phone,
			&i.Firstname,
			&i.Lastname,
			&i.Location,
			&i.PreferedProduct,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCustomer = `-- name: UpdateCustomer :one
UPDATE customer
SET
    phone = COALESCE($1, phone),
    firstname = COALESCE($2, firstname),
    lastname = COALESCE($3, lastname),
    location = COALESCE($4, location),
    prefered_product = COALESCE($5, prefered_product)
WHERE id = $6
RETURNING id, phone, firstname, lastname, location, prefered_product, created_at
`

type UpdateCustomerParams struct {
	Phone           sql.NullString `json:"phone"`
	Firstname       sql.NullString `json:"firstname"`
	Lastname        sql.NullString `json:"lastname"`
	Location        sql.NullString `json:"location"`
	PreferedProduct sql.NullString `json:"prefered_product"`
	ID              int32          `json:"id"`
}

func (q *Queries) UpdateCustomer(ctx context.Context, arg UpdateCustomerParams) (Customer, error) {
	row := q.db.QueryRowContext(ctx, updateCustomer,
		arg.Phone,
		arg.Firstname,
		arg.Lastname,
		arg.Location,
		arg.PreferedProduct,
		arg.ID,
	)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.Phone,
		&i.Firstname,
		&i.Lastname,
		&i.Location,
		&i.PreferedProduct,
		&i.CreatedAt,
	)
	return i, err
}

const updateCustomerPreferredProduct = `-- name: UpdateCustomerPreferredProduct :one
UPDATE customer
SET prefered_product = $1
WHERE id = $2
RETURNING id, phone, firstname, lastname, location, prefered_product, created_at
`

type UpdateCustomerPreferredProductParams struct {
	PreferedProduct sql.NullString `json:"prefered_product"`
	ID              int32          `json:"id"`
}

func (q *Queries) UpdateCustomerPreferredProduct(ctx context.Context, arg UpdateCustomerPreferredProductParams) (Customer, error) {
	row := q.db.QueryRowContext(ctx, updateCustomerPreferredProduct, arg.PreferedProduct, arg.ID)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.Phone,
		&i.Firstname,
		&i.Lastname,
		&i.Location,
		&i.PreferedProduct,
		&i.CreatedAt,
	)
	return i, err
}
