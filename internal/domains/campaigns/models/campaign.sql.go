// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: campaign.sql

package models

import (
	"context"
	"database/sql"
)

const countCampaigns = `-- name: CountCampaigns :one
SELECT COUNT(*) FROM campaigns
WHERE 
    ($1::text IS NULL OR channel = $1)
    AND ($2::text IS NULL OR status = $2)
`

type CountCampaignsParams struct {
	Channel sql.NullString `json:"channel"`
	Status  sql.NullString `json:"status"`
}

func (q *Queries) CountCampaigns(ctx context.Context, arg CountCampaignsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countCampaigns, arg.Channel, arg.Status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCampaign = `-- name: CreateCampaign :one
INSERT INTO campaigns (
    name,
    channel,
    status,
    scheduled_at,
    base_template
) VALUES (
    $1,
    $2,
    CASE 
        WHEN $3::TIMESTAMP IS NOT NULL AND $3::TIMESTAMP > CURRENT_TIMESTAMP THEN 'scheduled'
        ELSE 'draft'
    END,
    $3,
    $4
)
RETURNING id, name, channel, status, scheduled_at, base_template, created_at
`

type CreateCampaignParams struct {
	Name         string       `json:"name"`
	Channel      string       `json:"channel"`
	ScheduledAt  sql.NullTime `json:"scheduled_at"`
	BaseTemplate string       `json:"base_template"`
}

// campaigns.sql
func (q *Queries) CreateCampaign(ctx context.Context, arg CreateCampaignParams) (Campaign, error) {
	row := q.db.QueryRowContext(ctx, createCampaign,
		arg.Name,
		arg.Channel,
		arg.ScheduledAt,
		arg.BaseTemplate,
	)
	var i Campaign
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Channel,
		&i.Status,
		&i.ScheduledAt,
		&i.BaseTemplate,
		&i.CreatedAt,
	)
	return i, err
}

const getCampaign = `-- name: GetCampaign :one
SELECT id, name, channel, status, scheduled_at, base_template, created_at FROM campaigns
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetCampaign(ctx context.Context, id int32) (Campaign, error) {
	row := q.db.QueryRowContext(ctx, getCampaign, id)
	var i Campaign
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Channel,
		&i.Status,
		&i.ScheduledAt,
		&i.BaseTemplate,
		&i.CreatedAt,
	)
	return i, err
}

const getCampaignStats = `-- name: GetCampaignStats :one
SELECT
    COUNT(*) as total,
    COUNT(CASE WHEN status = 'pending' THEN 1 END) as pending,
    COUNT(CASE WHEN status = 'sending' THEN 1 END) as sending,
    COUNT(CASE WHEN status = 'sent' THEN 1 END) as sent,
    COUNT(CASE WHEN status = 'failed' THEN 1 END) as failed
FROM outbound_messages
WHERE campaign_id = $1
`

type GetCampaignStatsRow struct {
	Total   int64 `json:"total"`
	Pending int64 `json:"pending"`
	Sending int64 `json:"sending"`
	Sent    int64 `json:"sent"`
	Failed  int64 `json:"failed"`
}

func (q *Queries) GetCampaignStats(ctx context.Context, campaignID int32) (GetCampaignStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getCampaignStats, campaignID)
	var i GetCampaignStatsRow
	err := row.Scan(
		&i.Total,
		&i.Pending,
		&i.Sending,
		&i.Sent,
		&i.Failed,
	)
	return i, err
}

const getCampaignsReadyToSend = `-- name: GetCampaignsReadyToSend :many
UPDATE campaigns
SET status = 'sending'
WHERE id IN (
    SELECT id FROM campaigns
    WHERE status = 'scheduled'
    AND scheduled_at <= CURRENT_TIMESTAMP
    ORDER BY scheduled_at ASC
    FOR UPDATE SKIP LOCKED
)
RETURNING id, name, channel, base_template
`

type GetCampaignsReadyToSendRow struct {
	ID           int32  `json:"id"`
	Name         string `json:"name"`
	Channel      string `json:"channel"`
	BaseTemplate string `json:"base_template"`
}

func (q *Queries) GetCampaignsReadyToSend(ctx context.Context) ([]GetCampaignsReadyToSendRow, error) {
	rows, err := q.db.QueryContext(ctx, getCampaignsReadyToSend)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCampaignsReadyToSendRow
	for rows.Next() {
		var i GetCampaignsReadyToSendRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Channel,
			&i.BaseTemplate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCampaigns = `-- name: ListCampaigns :many
SELECT id, name, channel, status, scheduled_at, base_template, created_at FROM campaigns
WHERE 
    ($1::text IS NULL OR channel = $1)
    AND ($2::text IS NULL OR status = $2)
ORDER BY created_at DESC, id DESC
LIMIT $4 OFFSET $3
`

type ListCampaignsParams struct {
	Channel sql.NullString `json:"channel"`
	Status  sql.NullString `json:"status"`
	Offset  int32          `json:"offset"`
	Limit   int32          `json:"limit"`
}

func (q *Queries) ListCampaigns(ctx context.Context, arg ListCampaignsParams) ([]Campaign, error) {
	rows, err := q.db.QueryContext(ctx, listCampaigns,
		arg.Channel,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Campaign
	for rows.Next() {
		var i Campaign
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Channel,
			&i.Status,
			&i.ScheduledAt,
			&i.BaseTemplate,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCampaignStatus = `-- name: UpdateCampaignStatus :one
UPDATE campaigns
SET status = $1
WHERE id = $2
RETURNING id, name, channel, status, scheduled_at, base_template, created_at
`

type UpdateCampaignStatusParams struct {
	Status string `json:"status"`
	ID     int32  `json:"id"`
}

func (q *Queries) UpdateCampaignStatus(ctx context.Context, arg UpdateCampaignStatusParams) (Campaign, error) {
	row := q.db.QueryRowContext(ctx, updateCampaignStatus, arg.Status, arg.ID)
	var i Campaign
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Channel,
		&i.Status,
		&i.ScheduledAt,
		&i.BaseTemplate,
		&i.CreatedAt,
	)
	return i, err
}

const updateCampaignToSending = `-- name: UpdateCampaignToSending :one
UPDATE campaigns
SET status = 'sending'
WHERE id = $1 AND status IN ('draft', 'scheduled')
RETURNING id, name, channel, status, scheduled_at, base_template, created_at
`

func (q *Queries) UpdateCampaignToSending(ctx context.Context, id int32) (Campaign, error) {
	row := q.db.QueryRowContext(ctx, updateCampaignToSending, id)
	var i Campaign
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Channel,
		&i.Status,
		&i.ScheduledAt,
		&i.BaseTemplate,
		&i.CreatedAt,
	)
	return i, err
}
