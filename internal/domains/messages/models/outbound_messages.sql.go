// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: outbound_messages.sql

package models

import (
	"context"
	"database/sql"
	"time"

	"github.com/lib/pq"
)

const countOutboundMessagesByCampaign = `-- name: CountOutboundMessagesByCampaign :one
SELECT COUNT(*) FROM outbound_messages
WHERE campaign_id = $1
`

func (q *Queries) CountOutboundMessagesByCampaign(ctx context.Context, campaignID int32) (int64, error) {
	row := q.db.QueryRowContext(ctx, countOutboundMessagesByCampaign, campaignID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createOutboundMessage = `-- name: CreateOutboundMessage :one
INSERT INTO outbound_messages (
    campaign_id,
    customer_id,
    rendered_content,
    status
) VALUES (
    $1,
    $2,
    $3,
    'pending'
)
ON CONFLICT (campaign_id, customer_id) DO NOTHING
RETURNING id, campaign_id, customer_id, status, rendered_content, last_error, retry_count, provider_message_id, sent_at, failed_at, created_at, updated_at
`

type CreateOutboundMessageParams struct {
	CampaignID      int32  `json:"campaign_id"`
	CustomerID      int32  `json:"customer_id"`
	RenderedContent string `json:"rendered_content"`
}

func (q *Queries) CreateOutboundMessage(ctx context.Context, arg CreateOutboundMessageParams) (OutboundMessage, error) {
	row := q.db.QueryRowContext(ctx, createOutboundMessage, arg.CampaignID, arg.CustomerID, arg.RenderedContent)
	var i OutboundMessage
	err := row.Scan(
		&i.ID,
		&i.CampaignID,
		&i.CustomerID,
		&i.Status,
		&i.RenderedContent,
		&i.LastError,
		&i.RetryCount,
		&i.ProviderMessageID,
		&i.SentAt,
		&i.FailedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createOutboundMessageBatch = `-- name: CreateOutboundMessageBatch :many
INSERT INTO outbound_messages (
    campaign_id,
    customer_id,
    rendered_content,
    status
) 
SELECT 
    $1,
    unnest($2::integer[]),
    $3,
    'pending'
ON CONFLICT (campaign_id, customer_id) DO NOTHING
RETURNING id, campaign_id, customer_id, status, rendered_content, last_error, retry_count, provider_message_id, sent_at, failed_at, created_at, updated_at
`

type CreateOutboundMessageBatchParams struct {
	CampaignID      int32   `json:"campaign_id"`
	CustomerIds     []int32 `json:"customer_ids"`
	RenderedContent string  `json:"rendered_content"`
}

func (q *Queries) CreateOutboundMessageBatch(ctx context.Context, arg CreateOutboundMessageBatchParams) ([]OutboundMessage, error) {
	rows, err := q.db.QueryContext(ctx, createOutboundMessageBatch, arg.CampaignID, pq.Array(arg.CustomerIds), arg.RenderedContent)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OutboundMessage
	for rows.Next() {
		var i OutboundMessage
		if err := rows.Scan(
			&i.ID,
			&i.CampaignID,
			&i.CustomerID,
			&i.Status,
			&i.RenderedContent,
			&i.LastError,
			&i.RetryCount,
			&i.ProviderMessageID,
			&i.SentAt,
			&i.FailedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFailedMessagesWithRetry = `-- name: GetFailedMessagesWithRetry :many
SELECT id, campaign_id, customer_id, status, rendered_content, last_error, retry_count, provider_message_id, sent_at, failed_at, created_at, updated_at FROM outbound_messages
WHERE status = 'failed'
AND retry_count < $1
AND (updated_at < CURRENT_TIMESTAMP - INTERVAL '5 minutes' OR updated_at IS NULL)
ORDER BY updated_at ASC
LIMIT $3 OFFSET $2
`

type GetFailedMessagesWithRetryParams struct {
	MaxRetries int32 `json:"max_retries"`
	Offset     int32 `json:"offset"`
	Limit      int32 `json:"limit"`
}

func (q *Queries) GetFailedMessagesWithRetry(ctx context.Context, arg GetFailedMessagesWithRetryParams) ([]OutboundMessage, error) {
	rows, err := q.db.QueryContext(ctx, getFailedMessagesWithRetry, arg.MaxRetries, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OutboundMessage
	for rows.Next() {
		var i OutboundMessage
		if err := rows.Scan(
			&i.ID,
			&i.CampaignID,
			&i.CustomerID,
			&i.Status,
			&i.RenderedContent,
			&i.LastError,
			&i.RetryCount,
			&i.ProviderMessageID,
			&i.SentAt,
			&i.FailedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOutboundMessage = `-- name: GetOutboundMessage :one
SELECT id, campaign_id, customer_id, status, rendered_content, last_error, retry_count, provider_message_id, sent_at, failed_at, created_at, updated_at FROM outbound_messages
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetOutboundMessage(ctx context.Context, id int32) (OutboundMessage, error) {
	row := q.db.QueryRowContext(ctx, getOutboundMessage, id)
	var i OutboundMessage
	err := row.Scan(
		&i.ID,
		&i.CampaignID,
		&i.CustomerID,
		&i.Status,
		&i.RenderedContent,
		&i.LastError,
		&i.RetryCount,
		&i.ProviderMessageID,
		&i.SentAt,
		&i.FailedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOutboundMessageWithDetails = `-- name: GetOutboundMessageWithDetails :one
SELECT 
    om.id,
    om.campaign_id,
    om.customer_id,
    om.status,
    om.rendered_content,
    om.last_error,
    om.retry_count,
    om.provider_message_id,
    om.sent_at,
    om.failed_at,
    om.created_at,
    om.updated_at,
    c.phone as customer_phone,
    c.firstname as customer_firstname,
    c.lastname as customer_lastname,
    c.location as customer_location,
    c.prefered_product as customer_prefered_product,
    camp.base_template as campaign_base_template,
    camp.channel as campaign_channel
FROM outbound_messages om
INNER JOIN customer c ON om.customer_id = c.id
INNER JOIN campaigns camp ON om.campaign_id = camp.id
WHERE om.id = $1
LIMIT 1
`

type GetOutboundMessageWithDetailsRow struct {
	ID                      int32          `json:"id"`
	CampaignID              int32          `json:"campaign_id"`
	CustomerID              int32          `json:"customer_id"`
	Status                  string         `json:"status"`
	RenderedContent         string         `json:"rendered_content"`
	LastError               sql.NullString `json:"last_error"`
	RetryCount              int32          `json:"retry_count"`
	ProviderMessageID       sql.NullString `json:"provider_message_id"`
	SentAt                  sql.NullTime   `json:"sent_at"`
	FailedAt                sql.NullTime   `json:"failed_at"`
	CreatedAt               time.Time      `json:"created_at"`
	UpdatedAt               time.Time      `json:"updated_at"`
	CustomerPhone           string         `json:"customer_phone"`
	CustomerFirstname       string         `json:"customer_firstname"`
	CustomerLastname        string         `json:"customer_lastname"`
	CustomerLocation        sql.NullString `json:"customer_location"`
	CustomerPreferedProduct sql.NullString `json:"customer_prefered_product"`
	CampaignBaseTemplate    string         `json:"campaign_base_template"`
	CampaignChannel         string         `json:"campaign_channel"`
}

func (q *Queries) GetOutboundMessageWithDetails(ctx context.Context, id int32) (GetOutboundMessageWithDetailsRow, error) {
	row := q.db.QueryRowContext(ctx, getOutboundMessageWithDetails, id)
	var i GetOutboundMessageWithDetailsRow
	err := row.Scan(
		&i.ID,
		&i.CampaignID,
		&i.CustomerID,
		&i.Status,
		&i.RenderedContent,
		&i.LastError,
		&i.RetryCount,
		&i.ProviderMessageID,
		&i.SentAt,
		&i.FailedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CustomerPhone,
		&i.CustomerFirstname,
		&i.CustomerLastname,
		&i.CustomerLocation,
		&i.CustomerPreferedProduct,
		&i.CampaignBaseTemplate,
		&i.CampaignChannel,
	)
	return i, err
}

const getPendingMessagesForCampaign = `-- name: GetPendingMessagesForCampaign :many
SELECT id, campaign_id, customer_id, status, rendered_content, last_error, retry_count, provider_message_id, sent_at, failed_at, created_at, updated_at FROM outbound_messages
WHERE campaign_id = $1 
AND status = 'pending'
ORDER BY created_at ASC
LIMIT $3 OFFSET $2
`

type GetPendingMessagesForCampaignParams struct {
	CampaignID int32 `json:"campaign_id"`
	Offset     int32 `json:"offset"`
	Limit      int32 `json:"limit"`
}

func (q *Queries) GetPendingMessagesForCampaign(ctx context.Context, arg GetPendingMessagesForCampaignParams) ([]OutboundMessage, error) {
	rows, err := q.db.QueryContext(ctx, getPendingMessagesForCampaign, arg.CampaignID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OutboundMessage
	for rows.Next() {
		var i OutboundMessage
		if err := rows.Scan(
			&i.ID,
			&i.CampaignID,
			&i.CustomerID,
			&i.Status,
			&i.RenderedContent,
			&i.LastError,
			&i.RetryCount,
			&i.ProviderMessageID,
			&i.SentAt,
			&i.FailedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOutboundMessageStatus = `-- name: UpdateOutboundMessageStatus :one
UPDATE outbound_messages
SET 
    status = $1::varchar,
    sent_at = CASE WHEN $1::varchar = 'sent' THEN CURRENT_TIMESTAMP ELSE sent_at END,
    failed_at = CASE WHEN $1::varchar = 'failed' THEN CURRENT_TIMESTAMP ELSE failed_at END,
    last_error = $2,
    retry_count = CASE WHEN $1::varchar = 'failed' THEN retry_count + 1 ELSE retry_count END
WHERE id = $3
RETURNING id, campaign_id, customer_id, status, rendered_content, last_error, retry_count, provider_message_id, sent_at, failed_at, created_at, updated_at
`

type UpdateOutboundMessageStatusParams struct {
	Status       string         `json:"status"`
	ErrorMessage sql.NullString `json:"error_message"`
	ID           int32          `json:"id"`
}

func (q *Queries) UpdateOutboundMessageStatus(ctx context.Context, arg UpdateOutboundMessageStatusParams) (OutboundMessage, error) {
	row := q.db.QueryRowContext(ctx, updateOutboundMessageStatus, arg.Status, arg.ErrorMessage, arg.ID)
	var i OutboundMessage
	err := row.Scan(
		&i.ID,
		&i.CampaignID,
		&i.CustomerID,
		&i.Status,
		&i.RenderedContent,
		&i.LastError,
		&i.RetryCount,
		&i.ProviderMessageID,
		&i.SentAt,
		&i.FailedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateOutboundMessageWithRetry = `-- name: UpdateOutboundMessageWithRetry :one
UPDATE outbound_messages
SET 
    status = $1::varchar,
    sent_at = CASE WHEN $1::varchar = 'sent' THEN CURRENT_TIMESTAMP ELSE sent_at END,
    failed_at = CASE WHEN $1::varchar = 'failed' THEN CURRENT_TIMESTAMP ELSE failed_at END,
    last_error = $2,
    retry_count = CASE WHEN $1::varchar = 'failed' THEN retry_count + 1 ELSE retry_count END,
    provider_message_id = $3
WHERE id = $4
RETURNING id, campaign_id, customer_id, status, rendered_content, last_error, retry_count, provider_message_id, sent_at, failed_at, created_at, updated_at
`

type UpdateOutboundMessageWithRetryParams struct {
	Status            string         `json:"status"`
	LastError         sql.NullString `json:"last_error"`
	ProviderMessageID sql.NullString `json:"provider_message_id"`
	ID                int32          `json:"id"`
}

func (q *Queries) UpdateOutboundMessageWithRetry(ctx context.Context, arg UpdateOutboundMessageWithRetryParams) (OutboundMessage, error) {
	row := q.db.QueryRowContext(ctx, updateOutboundMessageWithRetry,
		arg.Status,
		arg.LastError,
		arg.ProviderMessageID,
		arg.ID,
	)
	var i OutboundMessage
	err := row.Scan(
		&i.ID,
		&i.CampaignID,
		&i.CustomerID,
		&i.Status,
		&i.RenderedContent,
		&i.LastError,
		&i.RetryCount,
		&i.ProviderMessageID,
		&i.SentAt,
		&i.FailedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
